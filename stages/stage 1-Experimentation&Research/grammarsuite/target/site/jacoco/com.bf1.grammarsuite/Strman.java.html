<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Strman.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">grammarsuite</a> &gt; <a href="index.source.html" class="el_package">com.bf1.grammarsuite</a> &gt; <span class="el_source">Strman.java</span></div><h1>Strman.java</h1><pre class="source lang-java linenums">/*
 *
 *  * The MIT License
 *  *
 *  * Copyright 2016 Shekhar Gulati &lt;shekhargulati84@gmail.com&gt;.
 *  *
 *  * Permission is hereby granted, free of charge, to any person obtaining a copy
 *  * of this software and associated documentation files (the &quot;Software&quot;), to deal
 *  * in the Software without restriction, including without limitation the rights
 *  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  * copies of the Software, and to permit persons to whom the Software is
 *  * furnished to do so, subject to the following conditions:
 *  *
 *  * The above copyright notice and this permission notice shall be included in
 *  * all copies or substantial portions of the Software.
 *  *
 *  * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  * THE SOFTWARE.
 *
 */
package com.bf1.grammarsuite;


import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static java.util.function.Function.identity;
import static java.util.stream.Collectors.*;

/**
 * A String manipulation library without any dependencies
 */
public abstract class Strman {

<span class="fc" id="L46">    private static final Predicate&lt;String&gt; NULL_STRING_PREDICATE = Objects::isNull;</span>
<span class="fc" id="L47">    private static final Supplier&lt;String&gt; NULL_STRING_MSG_SUPPLIER = () -&gt; &quot;'value' should be not null.&quot;;</span>
<span class="fc" id="L48">    private static final String[] EMPTY_ARRAY = new String[0];</span>

    private Strman() {
    }

    /**
     * Appends Strings to value
     *
     * @param value   initial String
     * @param appends an array of strings to append
     * @return full String
     */
    public static String append(final String value, final String... appends) {
<span class="fc" id="L61">        return appendArray(value, appends);</span>
    }

    /**
     * Append an array of String to value
     *
     * @param value   initial String
     * @param appends an array of strings to append
     * @return full String
     */
    public static String appendArray(final String value, final String[] appends) {
<span class="fc" id="L72">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L73" title="All 4 branches covered.">        if (appends == null || appends.length == 0) {</span>
<span class="fc" id="L74">            return value;</span>
        }
<span class="fc" id="L76">        StringJoiner joiner = new StringJoiner(&quot;&quot;);</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">        for (String append : appends) {</span>
<span class="fc" id="L78">            joiner.add(append);</span>
        }
<span class="fc" id="L80">        return value + joiner.toString();</span>
    }

    /**
     * Get the character at index. This method will take care of negative indexes.
     * The valid value of index is between -(length-1) to (length-1).
     * For values which don't fall under this range Optional.empty will be returned.
     *
     * @param value input value
     * @param index location
     * @return an Optional String if found else empty
     */
    public static Optional&lt;String&gt; at(final String value, int index) {
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (isNullOrEmpty(value)) {</span>
<span class="nc" id="L94">            return Optional.empty();</span>
        }
<span class="fc" id="L96">        int length = value.length();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (index &lt; 0) {</span>
<span class="fc" id="L98">            index = length + index;</span>
        }
<span class="fc bfc" id="L100" title="All 4 branches covered.">        return (index &lt; length &amp;&amp; index &gt;= 0) ? Optional.of(String.valueOf(value.charAt(index))) : Optional.empty();</span>
    }

    /**
     * Returns an array with strings between start and end.
     *
     * @param value input
     * @param start start
     * @param end   end
     * @return Array containing different parts between start and end.
     */

    public static String[] between(final String value, final String start, final String end) {
<span class="fc" id="L113">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="pc" id="L114">        validate(start, NULL_STRING_PREDICATE, () -&gt; &quot;'start' should be not null.&quot;);</span>
<span class="pc" id="L115">        validate(end, NULL_STRING_PREDICATE, () -&gt; &quot;'end' should be not null.&quot;);</span>

<span class="fc" id="L117">        String[] parts = value.split(end);</span>
<span class="fc" id="L118">        return Arrays.stream(parts)</span>
<span class="fc" id="L119">                .filter(subPart -&gt; subPart.contains(start))</span>
<span class="fc" id="L120">                .map(subPart -&gt; subPart.substring(subPart.indexOf(start) + start.length()))</span>
<span class="fc" id="L121">                .toArray(String[]::new);</span>
    }

    /**
     * Returns a String array consisting of the characters in the String.
     *
     * @param value input
     * @return character array
     */
    public static String[] chars(final String value) {
<span class="fc" id="L131">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L132">        return value.split(&quot;&quot;);</span>
    }

    /**
     * Replace consecutive whitespace characters with a single space.
     *
     * @param value input String
     * @return collapsed String
     */
    public static String collapseWhitespace(final String value) {
<span class="fc" id="L142">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L143">        return value.trim().replaceAll(&quot;\\s\\s+&quot;, &quot; &quot;);</span>
    }

    /**
     * Verifies that the needle is contained in the value. The search is case insensitive
     *
     * @param value  to search
     * @param needle to find
     * @return true if found else false.
     */
    public static boolean contains(final String value, final String needle) {
<span class="fc" id="L154">        return contains(value, needle, false);</span>
    }

    /**
     * Verifies that the needle is contained in the value.
     *
     * @param value         to search
     * @param needle        to find
     * @param caseSensitive true or false
     * @return true if found else false.
     */
    public static boolean contains(final String value, final String needle, final boolean caseSensitive) {
<span class="fc" id="L166">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc" id="L168">            return value.contains(needle);</span>
        }
<span class="fc" id="L170">        return value.toLowerCase().contains(needle.toLowerCase());</span>
    }

    /**
     * Verifies that all needles are contained in value. The search is case insensitive
     *
     * @param value   input String to search
     * @param needles needles to find
     * @return true if all needles are found else false.
     */
    public static boolean containsAll(final String value, final String[] needles) {
<span class="fc" id="L181">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L182">        return Arrays.stream(needles).allMatch(needle -&gt; contains(value, needle, false));</span>
    }

    /**
     * Verifies that all needles are contained in value
     *
     * @param value         input String to search
     * @param needles       needles to find
     * @param caseSensitive true or false
     * @return true if all needles are found else false.
     */
    public static boolean containsAll(final String value, final String[] needles, final boolean caseSensitive) {
<span class="fc" id="L194">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L195">        return Arrays.stream(needles).allMatch(needle -&gt; contains(value, needle, caseSensitive));</span>
    }

    /**
     * Verifies that one or more of needles are contained in value. This is case insensitive
     *
     * @param value   input
     * @param needles needles to search
     * @return boolean true if any needle is found else false
     */
    public static boolean containsAny(final String value, final String[] needles) {
<span class="fc" id="L206">        return containsAny(value, needles, false);</span>
    }

    /**
     * Verifies that one or more of needles are contained in value.
     *
     * @param value         input
     * @param needles       needles to search
     * @param caseSensitive true or false
     * @return boolean true if any needle is found else false
     */
    public static boolean containsAny(final String value, final String[] needles, final boolean caseSensitive) {
<span class="fc" id="L218">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L219">        return Arrays.stream(needles).anyMatch(needle -&gt; contains(value, needle, caseSensitive));</span>
    }

    /**
     * Count the number of times substr appears in value
     *
     * @param value  input
     * @param subStr to search
     * @return count of times substring exists
     */
    public static long countSubstr(final String value, final String subStr) {
<span class="fc" id="L230">        return countSubstr(value, subStr, true, false);</span>
    }

    /**
     * Count the number of times substr appears in value
     *
     * @param value            input
     * @param subStr           search string
     * @param caseSensitive    whether search should be case sensitive
     * @param allowOverlapping boolean to take into account overlapping
     * @return count of times substring exists
     */
    public static long countSubstr(final String value, final String subStr, final boolean caseSensitive,
                                   boolean allowOverlapping) {
<span class="fc" id="L244">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L245" title="All 4 branches covered.">        return countSubstr(caseSensitive ? value : value.toLowerCase(), caseSensitive ? subStr : subStr.toLowerCase(),</span>
                allowOverlapping, 0L);
    }

    /**
     * Test if value ends with search. The search is case sensitive.
     *
     * @param value  input string
     * @param search string to search
     * @return true or false
     */
    public static boolean endsWith(final String value, final String search) {
<span class="fc" id="L257">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L258">        return endsWith(value, search, value.length(), true);</span>
    }

    /**
     * Test if value ends with search.
     *
     * @param value         input string
     * @param search        string to search
     * @param caseSensitive true or false
     * @return true or false
     */
    public static boolean endsWith(final String value, final String search, final boolean caseSensitive) {
<span class="fc" id="L270">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L271">        return endsWith(value, search, value.length(), caseSensitive);</span>
    }

    /**
     * Test if value ends with search.
     *
     * @param value         input string
     * @param search        string to search
     * @param position      position till which you want to search.
     * @param caseSensitive true or false
     * @return true or false
     */
    public static boolean endsWith(final String value, final String search, final int position,
                                   final boolean caseSensitive) {
<span class="fc" id="L285">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L286">        int remainingLength = position - search.length();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">            return value.indexOf(search, remainingLength) &gt; -1;</span>
        }
<span class="fc bfc" id="L290" title="All 2 branches covered.">        return value.toLowerCase().indexOf(search.toLowerCase(), remainingLength) &gt; -1;</span>
    }

    /**
     * Ensures that the value begins with prefix. If it doesn't exist, it's prepended. It is case sensitive.
     *
     * @param value  input
     * @param prefix prefix
     * @return string with prefix if it was not present.
     */
    public static String ensureLeft(final String value, final String prefix) {
<span class="fc" id="L301">        return ensureLeft(value, prefix, true);</span>
    }

    /**
     * Ensures that the value begins with prefix. If it doesn't exist, it's prepended.
     *
     * @param value         input
     * @param prefix        prefix
     * @param caseSensitive true or false
     * @return string with prefix if it was not present.
     */
    public static String ensureLeft(final String value, final String prefix, final boolean caseSensitive) {
<span class="fc" id="L313">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">            return value.startsWith(prefix) ? value : prefix + value;</span>
        }
<span class="fc" id="L317">        String _value = value.toLowerCase();</span>
<span class="fc" id="L318">        String _prefix = prefix.toLowerCase();</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">        return _value.startsWith(_prefix) ? value : prefix + value;</span>
    }

    /**
     * Decodes data encoded with MIME base64
     *
     * @param value The data to decode
     * @return decoded data
     */
    public static String base64Decode(final String value) {
<span class="fc" id="L329">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L330">        return new String(Base64.getDecoder().decode(value), StandardCharsets.UTF_8);</span>
    }

    /**
     * Encodes data with MIME base64.
     *
     * @param value The data to encode
     * @return The encoded String
     */
    public static String base64Encode(final String value) {
<span class="fc" id="L340">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L341">        return Base64.getEncoder().encodeToString(value.getBytes(StandardCharsets.UTF_8));</span>
    }

    /**
     * Convert binary unicode (16 digits) string to string chars
     *
     * @param value The value to decode
     * @return The decoded String
     */
    public static String binDecode(final String value) {
<span class="fc" id="L351">        return decode(value, 16, 2);</span>
    }

    /**
     * Convert string chars to binary unicode (16 digits)
     *
     * @param value The value to encode
     * @return String in binary format
     */
    public static String binEncode(final String value) {
<span class="fc" id="L361">        return encode(value, 16, 2);</span>
    }

    /**
     * Convert decimal unicode (5 digits) string to string chars
     *
     * @param value The value to decode
     * @return decoded String
     */
    public static String decDecode(final String value) {
<span class="fc" id="L371">        return decode(value, 5, 10);</span>
    }

    /**
     * Convert string chars to decimal unicode (5 digits)
     *
     * @param value The value to encode
     * @return Encoded value
     */
    public static String decEncode(final String value) {
<span class="fc" id="L381">        return encode(value, 5, 10);</span>
    }

    /**
     * Ensures that the value ends with suffix. If it doesn't, it's appended. This operation is case sensitive.
     *
     * @param value  The input String
     * @param suffix The substr to be ensured to be right
     * @return The string which is guarenteed to start with substr
     */
    public static String ensureRight(final String value, final String suffix) {
<span class="fc" id="L392">        return ensureRight(value, suffix, true);</span>
    }

    /**
     * Ensures that the value ends with suffix. If it doesn't, it's appended.
     *
     * @param value         The input String
     * @param suffix        The substr to be ensured to be right
     * @param caseSensitive Use case (in-)sensitive matching for determining if value already ends with suffix
     * @return The string which is guarenteed to start with substr
     */
    public static String ensureRight(final String value, final String suffix, boolean caseSensitive) {
<span class="fc" id="L404">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">        return endsWith(value, suffix, caseSensitive) ? value : append(value, suffix);</span>
    }

    /**
     * Returns the first n chars of String
     *
     * @param value The input String
     * @param n     Number of chars to return
     * @return The first n chars
     */
    public static Optional&lt;String&gt; first(final String value, final int n) {
<span class="fc bfc" id="L416" title="All 2 branches covered.">        return Optional.ofNullable(value).filter(v -&gt; !v.isEmpty()).map(v -&gt; v.substring(0, n));</span>
    }

    /**
     * Return the first char of String
     *
     * @param value The input String
     * @return The first char
     */
    public static Optional&lt;String&gt; head(final String value) {
<span class="fc" id="L426">        return first(value, 1);</span>
    }

    /**
     * Formats a string using parameters
     *
     * @param value  The value to be formatted
     * @param params Parameters to be described in the string
     * @return The formatted string
     */
    public static String format(final String value, String... params) {
<span class="nc" id="L437">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="nc" id="L438">        Pattern p = Pattern.compile(&quot;\\{(\\w+)}&quot;);</span>
<span class="nc" id="L439">        Matcher m = p.matcher(value);</span>
<span class="nc" id="L440">        String result = value;</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        while (m.find()) {</span>
<span class="nc" id="L442">            int paramNumber = Integer.parseInt(m.group(1));</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">            if (params == null || paramNumber &gt;= params.length) {</span>
<span class="nc" id="L444">                throw new IllegalArgumentException(&quot;params does not have value for &quot; + m.group());</span>
            }
<span class="nc" id="L446">            result = result.replace(m.group(), params[paramNumber]);</span>
<span class="nc" id="L447">        }</span>
<span class="nc" id="L448">        return result;</span>
    }

    /**
     * Convert hexadecimal unicode (4 digits) string to string chars
     *
     * @param value The value to decode
     * @return The decoded String
     */
    public static String hexDecode(final String value) {
<span class="fc" id="L458">        return decode(value, 4, 16);</span>
    }

    /**
     * Convert string chars to hexadecimal unicode (4 digits)
     *
     * @param value The value to encode
     * @return String in hexadecimal format.
     */
    public static String hexEncode(final String value) {
<span class="fc" id="L468">        return encode(value, 4, 16);</span>
    }

    /**
     * The indexOf() method returns the index within the calling String of the first occurrence of the specified value, starting the search at fromIndex.
     * Returns -1 if the value is not found.
     *
     * @param value         The input String
     * @param needle        The search String
     * @param offset        The offset to start searching from.
     * @param caseSensitive boolean to indicate whether search should be case sensitive
     * @return Returns position of first occurrence of needle.
     */
    public static int indexOf(final String value, final String needle, int offset, boolean caseSensitive) {
<span class="fc" id="L482">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc" id="L484">            return value.indexOf(needle, offset);</span>
        }
<span class="fc" id="L486">        return value.toLowerCase().indexOf(needle.toLowerCase(), offset);</span>
    }

    /**
     * Tests if two Strings are inequal
     *
     * @param first  The first String
     * @param second The second String
     * @return true if first and second are not equal false otherwise
     */
    public static boolean unequal(final String first, final String second) {
<span class="fc bfc" id="L497" title="All 2 branches covered.">        return !Objects.equals(first, second);</span>
    }

    /**
     * Tests if two Strings are inequal
     *
     * @param first  The first String
     * @param second The second String
     * @return true if first and second are not equal false otherwise
     * @deprecated use unequal instead
     */
    public static boolean inequal(final String first, final String second) {
<span class="fc bfc" id="L509" title="All 2 branches covered.">        return !Objects.equals(first, second);</span>
    }

    /**
     * Inserts 'substr' into the 'value' at the 'index' provided.
     *
     * @param value  The input String
     * @param substr The String to insert
     * @param index  The index to insert substr
     * @return String with substr added
     */
    public static String insert(final String value, final String substr, final int index) {
<span class="fc" id="L521">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L522">        validate(substr, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">        if (index &gt; value.length()) {</span>
<span class="nc" id="L524">            return value;</span>
        }
<span class="fc" id="L526">        return append(value.substring(0, index), substr, value.substring(index));</span>
    }

    /**
     * Verifies if String is uppercase
     *
     * @param value The input String
     * @return true if String is uppercase false otherwise
     */
    public static boolean isUpperCase(final String value) {
<span class="fc" id="L536">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">        for (int i = 0; i &lt; value.length(); i++) {</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">            if (Character.isLowerCase(value.charAt(i))) {</span>
<span class="fc" id="L539">                return false;</span>
            }
        }
<span class="fc" id="L542">        return true;</span>
    }

    /**
     * Verifies if String is lower case
     *
     * @param value The input String
     * @return true if String is lowercase false otherwise
     */
    public static boolean isLowerCase(final String value) {
<span class="fc" id="L552">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">        for (int i = 0; i &lt; value.length(); i++) {</span>
<span class="fc bfc" id="L554" title="All 2 branches covered.">            if (Character.isUpperCase(value.charAt(i))) {</span>
<span class="fc" id="L555">                return false;</span>
            }
        }
<span class="fc" id="L558">        return true;</span>
    }

    /**
     * Return the last n chars of String
     *
     * @param value The input String
     * @param n     Number of chars to return
     * @return n Last characters
     */
    public static String last(final String value, int n) {
<span class="fc" id="L569">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        if (n &gt; value.length()) {</span>
<span class="fc" id="L571">            return value;</span>
        }
<span class="fc" id="L573">        return value.substring(value.length() - n);</span>
    }

    /**
     * Returns a new string of a given length such that the beginning of the string is padded.
     *
     * @param value  The input String
     * @param pad    The pad
     * @param length Length of the String we want
     * @return Padded String
     */
    public static String leftPad(final String value, final String pad, final int length) {
<span class="fc" id="L585">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L586">        validate(pad, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">        if (value.length() &gt; length) {</span>
<span class="fc" id="L588">            return value;</span>
        }
<span class="fc" id="L590">        return append(repeat(pad, length - value.length()), value);</span>
    }

    /**
     * Checks whether Object is String
     *
     * @param value The input String
     * @return true if Object is a String false otherwise
     */
    public static boolean isString(final Object value) {
<span class="pc bpc" id="L600" title="1 of 2 branches missed.">        if (Objects.isNull(value)) {</span>
<span class="nc" id="L601">            throw new IllegalArgumentException(&quot;value can't be null&quot;);</span>
        }
<span class="fc" id="L603">        return value instanceof String;</span>
    }

    /**
     * This method returns the index within the calling String object of the last occurrence of the specified value, searching backwards from the offset.
     * Returns -1 if the value is not found. The search starts from the end and case sensitive.
     *
     * @param value  The input String
     * @param needle The search String
     * @return Return position of the last occurrence of 'needle'.
     */
    public static int lastIndexOf(final String value, final String needle) {
<span class="fc" id="L615">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L616">        return lastIndexOf(value, needle, value.length(), true);</span>
    }

    /**
     * This method returns the index within the calling String object of the last occurrence of the specified value, searching backwards from the offset.
     * Returns -1 if the value is not found. The search starts from the end and case sensitive.
     *
     * @param value         The input String
     * @param needle        The search String
     * @param caseSensitive true or false
     * @return Return position of the last occurrence of 'needle'.
     */
    public static int lastIndexOf(final String value, final String needle, boolean caseSensitive) {
<span class="fc" id="L629">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L630">        return lastIndexOf(value, needle, value.length(), caseSensitive);</span>
    }

    /**
     * This method returns the index within the calling String object of the last occurrence of the specified value, searching backwards from the offset.
     * Returns -1 if the value is not found.
     *
     * @param value         The input String
     * @param needle        The search String
     * @param offset        The index to start search from
     * @param caseSensitive whether search should be case sensitive
     * @return Return position of the last occurrence of 'needle'.
     */
    public static int lastIndexOf(final String value, final String needle, final int offset,
                                  final boolean caseSensitive) {
<span class="fc" id="L645">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L646">        validate(needle, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L647" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc" id="L648">            return value.lastIndexOf(needle, offset);</span>
        }
<span class="fc" id="L650">        return value.toLowerCase().lastIndexOf(needle.toLowerCase(), offset);</span>
    }

    /**
     * Removes all spaces on left
     *
     * @param value The input String
     * @return String without left border spaces
     */
    public static String leftTrim(final String value) {
<span class="fc" id="L660">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L661">        return value.replaceAll(&quot;^\\s+&quot;, &quot;&quot;);</span>
    }

    /**
     * Returns length of String. Delegates to java.lang.String length method.
     *
     * @param value The input String
     * @return Length of the String
     */
    public static int length(final String value) {
<span class="fc" id="L671">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L672">        return value.length();</span>
    }

    /**
     * Return a new String starting with prepends
     *
     * @param value    The input String
     * @param prepends Strings to prepend
     * @return The prepended String
     */
    public static String prepend(final String value, final String... prepends) {
<span class="fc" id="L683">        return prependArray(value, prepends);</span>
    }

    /**
     * Return a new String starting with prepends
     *
     * @param value    The input String
     * @param prepends Strings to prepend
     * @return The prepended String
     */
    public static String prependArray(final String value, final String[] prepends) {
<span class="fc" id="L694">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="pc bpc" id="L695" title="1 of 4 branches missed.">        if (prepends == null || prepends.length == 0) {</span>
<span class="fc" id="L696">            return value;</span>
        }
<span class="fc" id="L698">        StringJoiner joiner = new StringJoiner(&quot;&quot;);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">        for (String prepend : prepends) {</span>
<span class="fc" id="L700">            joiner.add(prepend);</span>
        }
<span class="fc" id="L702">        return joiner.toString() + value;</span>
    }

    /**
     * Remove empty Strings from string array
     *
     * @param strings Array of String to be cleaned
     * @return Array of String without empty Strings
     */
    public static String[] removeEmptyStrings(String[] strings) {
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">        if (Objects.isNull(strings)) {</span>
<span class="nc" id="L713">            throw new IllegalArgumentException(&quot;Input array should not be null&quot;);</span>
        }
<span class="pc bpc" id="L715" title="2 of 4 branches missed.">        return Arrays.stream(strings).filter(str -&gt; str != null &amp;&amp; !str.trim().isEmpty()).toArray(String[]::new);</span>
    }

    /**
     * Returns a new String with the prefix removed, if present. This is case sensitive.
     *
     * @param value  The input String
     * @param prefix String to remove on left
     * @return The String without prefix
     */
    public static String removeLeft(final String value, final String prefix) {
<span class="fc" id="L726">        return removeLeft(value, prefix, true);</span>
    }

    /**
     * Returns a new String with the prefix removed, if present.
     *
     * @param value         The input String
     * @param prefix        String to remove on left
     * @param caseSensitive ensure case sensitivity
     * @return The String without prefix
     */
    public static String removeLeft(final String value, final String prefix, final boolean caseSensitive) {
<span class="fc" id="L738">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L739">        validate(prefix, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc bfc" id="L741" title="All 2 branches covered.">            return value.startsWith(prefix) ? value.substring(prefix.length()) : value;</span>
        }
<span class="fc bfc" id="L743" title="All 2 branches covered.">        return value.toLowerCase().startsWith(prefix.toLowerCase()) ? value.substring(prefix.length()) : value;</span>
    }

    /**
     * Remove all non word characters.
     *
     * @param value The input String
     * @return String without non-word characters
     */
    public static String removeNonWords(final String value) {
<span class="fc" id="L753">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L754">        return value.replaceAll(&quot;[^\\w]+&quot;, &quot;&quot;);</span>
    }

    /**
     * Returns a new string with the 'suffix' removed, if present. Search is case sensitive.
     *
     * @param value  The input String
     * @param suffix The suffix to remove
     * @return The String without suffix!
     */
    public static String removeRight(final String value, final String suffix) {
<span class="fc" id="L765">        return removeRight(value, suffix, true);</span>
    }

    /**
     * Returns a new string with the 'suffix' removed, if present.
     *
     * @param value         The input String
     * @param suffix        The suffix to remove
     * @param caseSensitive whether search should be case sensitive or not
     * @return The String without suffix!
     */
    public static String removeRight(final String value, final String suffix, final boolean caseSensitive) {
<span class="fc" id="L777">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L778">        validate(suffix, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L779" title="All 2 branches covered.">        return endsWith(value, suffix, caseSensitive) ? value</span>
<span class="fc" id="L780">                .substring(0, value.toLowerCase().lastIndexOf(suffix.toLowerCase())) : value;</span>
    }

    /**
     * Remove all spaces and replace for value.
     *
     * @param value The input String
     * @return String without spaces
     */
    public static String removeSpaces(final String value) {
<span class="fc" id="L790">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L791">        return value.replaceAll(&quot;\\s&quot;, &quot;&quot;);</span>
    }

    /**
     * Returns a repeated string given a multiplier.
     *
     * @param value      The input String
     * @param multiplier Number of repeats
     * @return The String repeated
     */
    public static String repeat(final String value, final int multiplier) {
<span class="fc" id="L802">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L803">        return Stream.generate(() -&gt; value).limit(multiplier).collect(joining());</span>
    }

    /**
     * Replace all occurrences of 'search' value to 'newvalue'. Uses String replace method.
     *
     * @param value         The input
     * @param search        The String to search
     * @param newValue      The String to replace
     * @param caseSensitive whether search should be case sensitive or not
     * @return String replaced with 'newvalue'.
     */
    public static String replace(final String value, final String search, final String newValue,
                                 final boolean caseSensitive) {
<span class="fc" id="L817">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L818">        validate(search, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L819" title="All 2 branches covered.">        if (caseSensitive) {</span>
<span class="fc" id="L820">            return value.replace(search, newValue);</span>
        }
<span class="fc" id="L822">        return Pattern.compile(search, Pattern.CASE_INSENSITIVE).matcher(value)</span>
<span class="fc" id="L823">                .replaceAll(Matcher.quoteReplacement(newValue));</span>
    }

    /**
     * Reverse the input String
     *
     * @param value The input String
     * @return Reversed String
     */
    public static String reverse(final String value) {
<span class="fc" id="L833">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L834">        return new StringBuilder(value).reverse().toString();</span>
    }

    /**
     * Returns a new string of a given length such that the ending of the string is padded.
     *
     * @param value  The input String
     * @param length Max length of String.
     * @param pad    Character to repeat
     * @return Right padded String
     */
    public static String rightPad(final String value, String pad, final int length) {
<span class="fc" id="L846">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L847" title="All 2 branches covered.">        if (value.length() &gt; length) {</span>
<span class="fc" id="L848">            return value;</span>
        }
<span class="fc" id="L850">        return append(value, repeat(pad, length - value.length()));</span>
    }

    /**
     * Remove all spaces on right.
     *
     * @param value The String
     * @return String without right boarders spaces.
     */
    public static String rightTrim(final String value) {
<span class="fc" id="L860">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L861">        return value.replaceAll(&quot;\\s+$&quot;, &quot;&quot;);</span>
    }

    /**
     * Truncate the string securely, not cutting a word in half. It always returns the last full word.
     *
     * @param value  The input String
     * @param length Max size of the truncated String
     * @param filler String that will be added to the end of the return string. Example: '...'
     * @return The truncated String
     */
    public static String safeTruncate(final String value, final int length, final String filler) {
<span class="fc" id="L873">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">        if (length == 0) {</span>
<span class="fc" id="L875">            return &quot;&quot;;</span>
        }
<span class="fc bfc" id="L877" title="All 2 branches covered.">        if (length &gt;= value.length()) {</span>
<span class="fc" id="L878">            return value;</span>
        }

<span class="fc" id="L881">        String[] words = words(value);</span>
<span class="fc" id="L882">        StringJoiner result = new StringJoiner(&quot; &quot;);</span>
<span class="fc" id="L883">        int spaceCount = 0;</span>
<span class="pc bpc" id="L884" title="1 of 2 branches missed.">        for (String word : words) {</span>
<span class="fc bfc" id="L885" title="All 2 branches covered.">            if (result.length() + word.length() + filler.length() + spaceCount &gt; length) {</span>
<span class="fc" id="L886">                break;</span>
            } else {
<span class="fc" id="L888">                result.add(word);</span>
<span class="fc" id="L889">                spaceCount++;</span>
            }
        }
<span class="fc" id="L892">        return append(result.toString(), filler);</span>
    }

    /**
     * Alias to String split function. Defined only for completeness.
     *
     * @param value The input String
     * @param regex The delimiting regular expression
     * @return String Array
     */
    public static String[] split(final String value, final String regex) {
<span class="fc" id="L903">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L904">        return value.split(regex);</span>
    }

    /**
     * Splits a String to words
     *
     * @param value The input String
     * @return Words Array
     */
    public static String[] words(final String value) {
<span class="fc" id="L914">        return words(value, &quot;\\s+&quot;);</span>
    }

    /**
     * Splits a String to words by delimiter, \s+ by default
     *
     * @param value     The input String
     * @param delimiter delimiter for splitting input String
     * @return words array
     */
    public static String[] words(final String value, final String delimiter) {
<span class="fc" id="L925">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L926">        return value.split(delimiter);</span>
    }


    /**
     * Truncate the unsecured form string, cutting the independent string of required position.
     *
     * @param value  Value will be truncated unsecurely.
     * @param length Size of the returned string.
     * @param filler Value that will be added to the end of the return string. Example: '...'
     * @return String truncated unsafely.
     */
    public static String truncate(final String value, final int length, final String filler) {
<span class="fc" id="L939">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (length == 0) {</span>
<span class="fc" id="L941">            return &quot;&quot;;</span>
        }
<span class="fc bfc" id="L943" title="All 2 branches covered.">        if (length &gt;= value.length()) {</span>
<span class="fc" id="L944">            return value;</span>
        }
<span class="fc" id="L946">        return append(value.substring(0, length - filler.length()), filler);</span>
    }

    /**
     * Converts all HTML entities to applicable characters.
     *
     * @param encodedHtml The encoded HTML
     * @return The decoded HTML
     */
    public static String htmlDecode(final String encodedHtml) {
<span class="fc" id="L956">        validate(encodedHtml, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L957">        String[] entities = encodedHtml.split(&quot;&amp;\\W+;&quot;);</span>
<span class="fc" id="L958">        return Arrays.stream(entities).map(e -&gt; HtmlEntities.decodedEntities.get(e)).collect(joining());</span>
    }

    /**
     * Convert all applicable characters to HTML entities.
     *
     * @param html The HTML to encode
     * @return The encoded data
     */
    public static String htmlEncode(final String html) {
<span class="fc" id="L968">        validate(html, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L969">        return html.chars().mapToObj(c -&gt; &quot;\\u&quot; + String.format(&quot;%04x&quot;, c).toUpperCase())</span>
<span class="fc" id="L970">                .map(HtmlEntities.encodedEntities::get).collect(joining());</span>
    }

    /**
     * It returns a string with its characters in random order.
     *
     * @param value The input String
     * @return The shuffled String
     */
    public static String shuffle(final String value) {
<span class="fc" id="L980">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L981">        String[] chars = chars(value);</span>
<span class="fc" id="L982">        Random random = new Random();</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="fc" id="L984">            int r = random.nextInt(chars.length);</span>
<span class="fc" id="L985">            String tmp = chars[i];</span>
<span class="fc" id="L986">            chars[i] = chars[r];</span>
<span class="fc" id="L987">            chars[r] = tmp;</span>
        }
<span class="fc" id="L989">        return Arrays.stream(chars).collect(joining());</span>
    }

    /**
     * Alias of substring method
     *
     * @param value The input String
     * @param begin Start of slice.
     * @param end   End of slice.
     * @return The String sliced!
     */
    public static String slice(final String value, int begin, int end) {
<span class="fc" id="L1001">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1002">        return value.substring(begin, end);</span>
    }

    /**
     * Convert a String to a slug
     *
     * @param value The value to slugify
     * @return The slugified value
     */
    public static String slugify(final String value) {
<span class="fc" id="L1012">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1013">        String transliterated = transliterate(collapseWhitespace(value.trim().toLowerCase()));</span>
<span class="fc" id="L1014">        return Arrays.stream(words(transliterated.replace(&quot;&amp;&quot;, &quot;-and-&quot;), &quot;\\W+&quot;)).collect(joining(&quot;-&quot;));</span>
    }

    /**
     * Remove all non valid characters.
     *
     * @param value The input String
     * @return String without non valid characters.
     */
    public static String transliterate(final String value) {
<span class="fc" id="L1024">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1025">        String result = value;</span>
<span class="fc" id="L1026">        Set&lt;Map.Entry&lt;String, List&lt;String&gt;&gt;&gt; entries = Ascii.ascii.entrySet();</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">        for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : entries) {</span>
<span class="fc bfc" id="L1028" title="All 2 branches covered.">            for (String ch : entry.getValue()) {</span>
<span class="fc" id="L1029">                result = result.replace(ch, entry.getKey());</span>
<span class="fc" id="L1030">            }</span>
<span class="fc" id="L1031">        }</span>
<span class="fc" id="L1032">        return result;</span>
    }

    /**
     * Surrounds a 'value' with the given 'prefix' and 'suffix'.
     *
     * @param value  The input String
     * @param prefix prefix. If suffix is null then prefix is used
     * @param suffix suffix
     * @return The String with surround substrs!
     */
    public static String surround(final String value, final String prefix, final String suffix) {
<span class="fc" id="L1044">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1045">        String _prefix = Optional.ofNullable(prefix).orElse(&quot;&quot;);</span>
<span class="fc" id="L1046">        return append(_prefix, value, Optional.ofNullable(suffix).orElse(_prefix));</span>
    }

    /**
     * Transform to camelCase
     *
     * @param value The input String
     * @return String in camelCase.
     */
    public static String toCamelCase(final String value) {
<span class="fc bfc" id="L1056" title="All 4 branches covered.">        if (value == null || value.length() == 0) {</span>
<span class="fc" id="L1057">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1059">        String str = toStudlyCase(value);</span>
<span class="fc" id="L1060">        return str.substring(0, 1).toLowerCase() + str.substring(1);</span>
    }

    /**
     * Transform to StudlyCaps.
     *
     * @param value The input String
     * @return String in StudlyCaps.
     */
    public static String toStudlyCase(final String value) {
<span class="fc" id="L1070">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1071">        String[] words = collapseWhitespace(value.trim()).split(&quot;\\s*(_|-|\\s)\\s*&quot;);</span>
<span class="fc bfc" id="L1072" title="All 2 branches covered.">        return Arrays.stream(words).filter(w -&gt; !w.trim().isEmpty()).map(Strman::upperFirst).collect(joining());</span>
    }

    /**
     * Return tail of the String
     *
     * @param value The input String
     * @return String tail
     */
    public static Optional&lt;String&gt; tail(final String value) {
<span class="fc bfc" id="L1082" title="All 2 branches covered.">        return Optional.ofNullable(value).filter(v -&gt; !v.isEmpty()).map(v -&gt; last(v, v.length() - 1));</span>
    }

    /**
     * Decamelize String
     *
     * @param value The input String
     * @param chr   string to use
     * @return String decamelized.
     */
    public static String toDecamelize(final String value, final String chr) {
<span class="fc" id="L1093">        String camelCasedString = toCamelCase(value);</span>
<span class="fc" id="L1094">        String[] words = camelCasedString.split(&quot;(?=\\p{Upper})&quot;);</span>
<span class="fc" id="L1095">        return Arrays.stream(words).map(String::toLowerCase).collect(joining(Optional.ofNullable(chr).orElse(&quot; &quot;)));</span>
    }

    /**
     * Transform to kebab-case.
     *
     * @param value The input String
     * @return String in kebab-case.
     */
    public static String toKebabCase(final String value) {
<span class="fc" id="L1105">        return toDecamelize(value, &quot;-&quot;);</span>
    }

    /**
     * Transform to snake_case.
     *
     * @param value The input String
     * @return String in snake_case.
     */
    public static String toSnakeCase(final String value) {
<span class="fc" id="L1115">        return toDecamelize(value, &quot;_&quot;);</span>
    }

    public static String decode(final String value, final int digits, final int radix) {
<span class="fc" id="L1119">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1120">        return Arrays.stream(value.split(&quot;(?&lt;=\\G.{&quot; + digits + &quot;})&quot;))</span>
<span class="fc" id="L1121">                .map(data -&gt; String.valueOf(Character.toChars(Integer.parseInt(data, radix))))</span>
<span class="fc" id="L1122">                .collect(joining());</span>
    }

    public static String encode(final String value, final int digits, final int radix) {
<span class="fc" id="L1126">        validate(value, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="fc" id="L1127">        return value.chars().mapToObj(ch -&gt; leftPad(Integer.toString(ch, radix), &quot;0&quot;, digits)).collect(joining());</span>
    }

    /**
     * Join concatenates all the elements of the strings array into a single String. The separator string is placed between elements in the resulting string.
     *
     * @param strings   The input array to concatenate
     * @param separator The separator to use
     * @return Concatenated String
     */
    public static String join(final String[] strings, final String separator) throws IllegalArgumentException {
<span class="fc bfc" id="L1138" title="All 2 branches covered.">        if (strings == null) {</span>
<span class="fc" id="L1139">            throw new IllegalArgumentException(&quot;Input array 'strings' can't be null&quot;);</span>
        }
<span class="fc bfc" id="L1141" title="All 2 branches covered.">        if (separator == null) {</span>
<span class="fc" id="L1142">            throw new IllegalArgumentException(&quot;separator can't be null&quot;);</span>
        }
<span class="fc" id="L1144">        StringJoiner joiner = new StringJoiner(separator);</span>
<span class="fc bfc" id="L1145" title="All 2 branches covered.">        for (String el : strings) {</span>
<span class="fc" id="L1146">            joiner.add(el);</span>
        }
<span class="fc" id="L1148">        return joiner.toString();</span>
    }

    /**
     * Converts the first character of string to upper case and the remaining to lower case.
     *
     * @param input The string to capitalize
     * @return The capitalized string
     */
    public static String capitalize(final String input) throws IllegalArgumentException {
<span class="fc bfc" id="L1158" title="All 2 branches covered.">        if (input == null) {</span>
<span class="fc" id="L1159">            throw new IllegalArgumentException(&quot;input can't be null&quot;);</span>
        }
<span class="fc bfc" id="L1161" title="All 2 branches covered.">        if (input.length() == 0) {</span>
<span class="fc" id="L1162">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1164">        return head(input).map(String::toUpperCase).map(h -&gt; tail(input).map(t -&gt; h + t.toLowerCase()).orElse(h)).get();</span>
    }

    /**
     * Converts the first character of string to lower case.
     *
     * @param input The string to convert
     * @return The converted string
     */
    public static String lowerFirst(final String input) throws IllegalArgumentException {
<span class="fc bfc" id="L1174" title="All 2 branches covered.">        if (input == null) {</span>
<span class="fc" id="L1175">            throw new IllegalArgumentException(&quot;input can't be null&quot;);</span>
        }
<span class="fc bfc" id="L1177" title="All 2 branches covered.">        if (input.length() == 0) {</span>
<span class="fc" id="L1178">            return &quot;&quot;;</span>
        }

<span class="fc" id="L1181">        return head(input).map(String::toLowerCase).map(h -&gt; tail(input).map(t -&gt; h + t).orElse(h)).get();</span>
    }

    /**
     * Verifies whether String is enclosed by encloser
     *
     * @param input    The input String
     * @param encloser String which encloses input String
     * @return true if enclosed false otherwise
     */
    public static boolean isEnclosedBetween(final String input, final String encloser) {
<span class="fc" id="L1192">        return isEnclosedBetween(input, encloser, encloser);</span>
    }

    /**
     * Verifies whether String is enclosed by encloser
     *
     * @param input         The input String
     * @param leftEncloser  String which encloses input String at left start
     * @param rightEncloser String which encloses input String at the right end
     * @return true if enclosed false otherwise
     */
    public static boolean isEnclosedBetween(final String input, final String leftEncloser, String rightEncloser) {
<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">        if (input == null) {</span>
<span class="nc" id="L1205">            throw new IllegalArgumentException(&quot;input can't be null&quot;);</span>
        }
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">        if (leftEncloser == null) {</span>
<span class="nc" id="L1208">            throw new IllegalArgumentException(&quot;leftEncloser can't be null&quot;);</span>
        }
<span class="pc bpc" id="L1210" title="1 of 2 branches missed.">        if (rightEncloser == null) {</span>
<span class="nc" id="L1211">            throw new IllegalArgumentException(&quot;rightEncloser can't be null&quot;);</span>
        }
<span class="fc bfc" id="L1213" title="All 4 branches covered.">        return input.startsWith(leftEncloser) &amp;&amp; input.endsWith(rightEncloser);</span>
    }

    /**
     * Converts the first character of string to upper case.
     *
     * @param input The string to convert.
     * @return Returns the converted string.
     */
    public static String upperFirst(String input) {
<span class="fc bfc" id="L1223" title="All 2 branches covered.">        if (input == null) {</span>
<span class="fc" id="L1224">            throw new IllegalArgumentException(&quot;input can't be null&quot;);</span>
        }
<span class="fc" id="L1226">        return head(input).map(String::toUpperCase).map(h -&gt; tail(input).map(t -&gt; h + t).orElse(h)).get();</span>
    }

    /**
     * Removes leading whitespace from string.
     *
     * @param input The string to trim.
     * @return Returns the trimmed string.
     */
    public static Optional&lt;String&gt; trimStart(final String input) {
<span class="pc bpc" id="L1236" title="1 of 2 branches missed.">        return Optional.ofNullable(input).filter(v -&gt; !v.isEmpty()).map(Strman::leftTrim);</span>
    }

    /**
     * Removes leading characters from string.
     *
     * @param input The string to trim.
     * @param chars The characters to trim.
     * @return Returns the trimmed string.
     */
    public static Optional&lt;String&gt; trimStart(final String input, String... chars) {
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">        return Optional.ofNullable(input).filter(v -&gt; !v.isEmpty()).map(v -&gt; {</span>
<span class="fc" id="L1248">            String pattern = String.format(&quot;^[%s]+&quot;, join(chars, &quot;\\&quot;));</span>
<span class="fc" id="L1249">            return v.replaceAll(pattern, &quot;&quot;);</span>
        });
    }

    /**
     * Removes trailing whitespace from string.
     *
     * @param input The string to trim.
     * @return Returns the trimmed string.
     */
    public static Optional&lt;String&gt; trimEnd(final String input) {
<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">        return Optional.ofNullable(input).filter(v -&gt; !v.isEmpty()).map(Strman::rightTrim);</span>
    }

    /**
     * Removes trailing characters from string.
     *
     * @param input The string to trim.
     * @param chars The characters to trim.
     * @return Returns the trimmed string.
     */
    public static Optional&lt;String&gt; trimEnd(final String input, String... chars) {
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">        return Optional.ofNullable(input).filter(v -&gt; !v.isEmpty()).map(v -&gt; {</span>
<span class="fc" id="L1272">            String pattern = String.format(&quot;[%s]+$&quot;, join(chars, &quot;\\&quot;));</span>
<span class="fc" id="L1273">            return v.replaceAll(pattern, &quot;&quot;);</span>
        });
    }

    /**
     * Counts the number of occurrences of each character in the string
     *
     * @param input The input string
     * @return A map containing the number of occurrences of each character in the string
     */
    public static Map&lt;Character, Long&gt; charsCount(String input) {
<span class="fc bfc" id="L1284" title="All 2 branches covered.">        if (isNullOrEmpty(input)) {</span>
<span class="fc" id="L1285">            return Collections.emptyMap();</span>
        }

<span class="fc" id="L1288">        return input.chars().mapToObj(c -&gt; (char) c).collect(groupingBy(identity(), counting()));</span>
    }

    /**
     * Checks if string is empty.  This is a null safe check and will return true when string is null.
     *
     * @param input The input string
     * @return true if input string is null or empty
     */
    public static boolean isBlank(String input) {
<span class="fc bfc" id="L1298" title="All 4 branches covered.">        return input == null || input.isEmpty();</span>
    }

    /**
     * Changes passed in string to all lower case and adds underscore between words.
     *
     * @param input The input string
     * @return the input string in all lower case with underscores between words
     */
    public static String underscored(final String input) {
<span class="fc bfc" id="L1308" title="All 4 branches covered.">        if (input == null || input.length() == 0) {</span>
<span class="fc" id="L1309">            return &quot;&quot;;</span>
        }

<span class="fc" id="L1312">        return input.trim().replaceAll(&quot;([a-z\\d])([A-Z]+)&quot;, &quot;$1_$2&quot;).replaceAll(&quot;[-\\s]+&quot;, &quot;_&quot;).toLowerCase();</span>
    }

    /**
     * Aggregates the contents of n strings into a single list of tuples.
     *
     * @param inputs A list of strings.
     * @return A list of strings if none of the strings in the input is null or empty.
     * An empty list otherwise.
     */
    public static List&lt;String&gt; zip(String... inputs) {
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">        if (inputs.length == 0) {</span>
<span class="nc" id="L1324">            return Collections.emptyList();</span>
        }
<span class="fc bfc" id="L1326" title="All 2 branches covered.">        OptionalInt min = Arrays.stream(inputs).mapToInt(str -&gt; str == null ? 0 : str.length()).min();</span>
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">        if (!min.isPresent()) {</span>
<span class="nc" id="L1328">            return Collections.emptyList();</span>
        }
<span class="fc" id="L1330">        return IntStream.range(0, min.getAsInt())</span>
<span class="fc" id="L1331">                .mapToObj(elementIndex -&gt; Arrays.stream(inputs)</span>
<span class="fc" id="L1332">                        .map(input -&gt; String.valueOf(input.charAt(elementIndex)))</span>
<span class="fc" id="L1333">                        .collect(joining()))</span>
<span class="fc" id="L1334">                .collect(toList());</span>
    }

    /**
     * Split lines to an array
     *
     * @param input The input String
     * @return lines in an array
     */
    public static String[] lines(String input) {
<span class="fc bfc" id="L1344" title="All 2 branches covered.">        if (input == null) {</span>
<span class="fc" id="L1345">            return EMPTY_ARRAY;</span>
        }
<span class="fc" id="L1347">        return input.split(&quot;\r\n?|\n&quot;);</span>
    }

    /**
     * Converts a underscored or camelized string into an dasherized one.
     *
     * @param input The input String
     * @return dasherized String.
     */
    public static String dasherize(String input) {
<span class="fc" id="L1357">        return toKebabCase(input);</span>
    }

    /**
     * Converts an underscored, camelized, or dasherized string into a humanized one. Also removes beginning and ending whitespace.
     *
     * @param input The input String
     * @return humanized version of String
     */
    public static String humanize(final String input) {
<span class="fc bfc" id="L1367" title="All 4 branches covered.">        if (input == null || input.length() == 0) {</span>
<span class="fc" id="L1368">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1370">        return upperFirst(underscored(input).replaceAll(&quot;_&quot;, &quot; &quot;));</span>
    }

    /**
     * Returns a copy of the string in which all the case-based characters have had their case swapped.
     *
     * @param input Input string
     * @return String with all the case swapped
     */
    public static String swapCase(String input) {
<span class="fc bfc" id="L1380" title="All 4 branches covered.">        if (input == null || input.length() == 0) {</span>
<span class="fc" id="L1381">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1383">        StringBuilder resultBuilder = new StringBuilder();</span>
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        for (char ch : input.toCharArray()) {</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">            if (Character.isUpperCase(ch)) {</span>
<span class="fc" id="L1386">                resultBuilder.append(Character.toLowerCase(ch));</span>
            } else {
<span class="fc" id="L1388">                resultBuilder.append(Character.toUpperCase(ch));</span>
            }
        }
<span class="fc" id="L1391">        return resultBuilder.toString();</span>
    }

    /**
     * Returns a string representation of the number passed in where groups of three digits are delimited by comma
     *
     * @param number Input number
     * @return formatted String
     */
    public static String formatNumber(long number) {
<span class="nc" id="L1401">        String stringRepresentation = Long.toString(number);</span>
<span class="nc" id="L1402">        StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1403">        int bound = stringRepresentation.length() - 1;</span>
<span class="nc" id="L1404">        String delimiter = &quot;,&quot;;</span>
<span class="nc" id="L1405">        int counter = 0;</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">        for (int i = bound; i &gt;= 0; i--) {</span>
<span class="nc" id="L1407">            char c = stringRepresentation.charAt(i);</span>
<span class="nc bnc" id="L1408" title="All 4 branches missed.">            if (i != bound &amp;&amp; counter % 3 == 0) {</span>
<span class="nc" id="L1409">                sb.append(delimiter);</span>
            }
<span class="nc" id="L1411">            sb.append(c);</span>
<span class="nc" id="L1412">            counter++;</span>
        }
<span class="nc" id="L1414">        return sb.reverse().toString();</span>
    }

    public static String[] chop(String input, int step) {
<span class="fc bfc" id="L1418" title="All 4 branches covered.">        if (input == null || input.length() == 0) {</span>
<span class="fc" id="L1419">            return EMPTY_ARRAY;</span>
        }
<span class="fc bfc" id="L1421" title="All 2 branches covered.">        if (step == 0) {</span>
<span class="fc" id="L1422">            return new String[]{input};</span>
        }
<span class="fc" id="L1424">        int strLength = input.length();</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        int iterations = strLength % step == 0 ? strLength / step : strLength / step + 1;</span>
<span class="fc" id="L1426">        return IntStream.iterate(0, i -&gt; i + step)</span>
<span class="fc" id="L1427">                .limit(iterations)</span>
<span class="fc bfc" id="L1428" title="All 2 branches covered.">                .mapToObj(i -&gt; input.substring(i, (i + step) &lt; strLength ? i + step : strLength))</span>
<span class="fc" id="L1429">                .toArray(String[]::new);</span>
    }

    /**
     * Converts a String into its Start Case version
     * https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage
     *
     * @param input The input String
     * @return Start Case String
     */
    public static String startCase(final String input) {
<span class="nc" id="L1440">        validate(input, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
        // split into a word when we encounter a space, or an underscore, or a dash, or a switch from lower to upper case
<span class="nc" id="L1442">        String[] words = words(input, &quot;\\s|_|-|(?&lt;=[a-z])(?=[A-Z])&quot;);</span>
<span class="nc bnc" id="L1443" title="All 2 branches missed.">        return Arrays.stream(words).filter(w -&gt; !w.trim().isEmpty())</span>
<span class="nc" id="L1444">            .map(w -&gt; upperFirst(w.toLowerCase())).collect(joining(&quot; &quot;));</span>
    }

    public static String escapeRegExp(final String input) {
<span class="nc" id="L1448">        validate(input, NULL_STRING_PREDICATE, NULL_STRING_MSG_SUPPLIER);</span>
<span class="nc" id="L1449">        return input.replaceAll(&quot;[\\\\\\^\\$\\*\\+\\-\\?\\.\\|\\(\\)\\{\\}\\[\\]]&quot;, &quot;\\\\$0&quot;);</span>
    }

    private static void validate(String value, Predicate&lt;String&gt; predicate, final Supplier&lt;String&gt; supplier) {
<span class="fc bfc" id="L1453" title="All 2 branches covered.">        if (predicate.test(value)) {</span>
<span class="fc" id="L1454">            throw new IllegalArgumentException(supplier.get());</span>
        }
<span class="fc" id="L1456">    }</span>

    private static long countSubstr(String value, String subStr, boolean allowOverlapping, long count) {
<span class="fc" id="L1459">        int position = value.indexOf(subStr);</span>
<span class="fc bfc" id="L1460" title="All 2 branches covered.">        if (position == -1) {</span>
<span class="fc" id="L1461">            return count;</span>
        }
        int offset;
<span class="fc bfc" id="L1464" title="All 2 branches covered.">        if (!allowOverlapping) {</span>
<span class="fc" id="L1465">            offset = position + subStr.length();</span>
        } else {
<span class="fc" id="L1467">            offset = position + 1;</span>
        }
<span class="fc" id="L1469">        return countSubstr(value.substring(offset), subStr, allowOverlapping, ++count);</span>
    }

    private static boolean isNullOrEmpty(String input) {
<span class="fc bfc" id="L1473" title="All 4 branches covered.">        return input == null || input.isEmpty();</span>
    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>